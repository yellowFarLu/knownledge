# 哈夫曼树



## 概念

所有叶子节点的带权路径长度总和最小的二叉树，称为哈弗曼树。

带权路径长度总和 = 节点1的权重 * 节点1的路径长度 +   节点2的权重 * 节点2的路径长度 + ........   节点n的权重 * 节点n的路径长度



扩充二叉树：在二叉树里出现空子树的位置增加空树叶，所形成的二叉树称为扩充二叉树

满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。

度：二叉树中结点的子树数目称为结点的度



### 举例

下图表示了三棵具有4个外部结点的二叉树，各外部结点的权值分别为6，2，3，4（即这4个节点做叶子）。

![image-20200215101815301](https://tva1.sinaimg.cn/large/0082zybpgy1gbwvbpjflij30tk08gjsh.jpg)

它们的带权外部路径长度分别为：
(a) 6×2 + 2×2 + 3×2 + 4×2 = 30
(b) 6×2 + 2×3 + 3×3 + 4×1 = 31
(c) 6×1 + 2×3 + 3×3 + 4×2 = 29

其中，c中所示的二叉树外部带权路径长度最小。可以验证，
它就是一棵Huffman树，也就是说，这棵树在所有的具有6，2，3，
4权值的叶结点的二叉树中带权外部路径长度最小。





### 性质

- 1、哈夫曼树只有度为0和2的结点，无度为1的结点；
- 2、权值大的结点离根结点近；
- 3、n个叶子的哈夫曼树的形态一般不唯一，但WPL是相同的；
- 4、n个叶子的哈夫曼树共有2n-1个结点。

![image-20200215103710974](https://tva1.sinaimg.cn/large/0082zybpgy1gbwvvhr84jj31380ti12l.jpg)







### 构建哈弗曼树

建立Huffman编码树：

- (1) 对于给定的n个权值w0，w1，…，wn-1(n≥2)，构成n棵二叉树的集合T = { T0，T1，T2，…，Tn－1}，使得每一棵扩充二叉树只具有一个带权为wi的根结点。
- (2) 构造一棵新的二叉树，在集合T中找出两个权值最小的树作为新树根结点的左右子树，把新树根结点的权值赋为其左右子树根结点的和。 
- (3) 在集合T中删除这两棵树，并把得到的新扩充二叉树加入到集合中。
- (4) 重复步骤(2)、(3)的操作，直到集合T中只含有一棵树为止。



比如说有权重为2、3、4、6的叶子节点，可以构建成如下哈夫曼树：

![image-20200215103128949](https://tva1.sinaimg.cn/large/0082zybpgy1gbwvpkdf82j31e20s8wgt.jpg)

详细可以参考PPT。



**为什么上述算法能够构建出带权路径最小的二叉树（哈夫曼树）？**

我的理解是：每次选取权重最小的2个节点，相当于使用了贪心算法，通过局部构建带权路径总和最小的二叉树，最终完整构建出的就是带权路径最小的二叉树。







## 哈夫曼编码



### 概念

哈夫曼编码是一种编码方式，使用这种编码得到的电报文总长度最小。

前缀码：任何一个字符的编码都不能是其他字符编码的前缀。



Huffman编码过程如下：

- 构造哈弗曼树
- 把从每个结点引向其左子结点的边标上号码0，从每个结点引向其右子结点的边标上号码1
- 从根结点到每个叶结点路径上的编号连接起来就是这个外部结点所代表字符的编码。得到的二进制前缀码就称作Huffman编码

![image-20200215110438944](https://tva1.sinaimg.cn/large/0082zybpgy1gbwwo3201jj31ef0u00x4.jpg)



