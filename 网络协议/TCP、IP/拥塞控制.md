# 拥塞控制

TCP 利用滑动窗口来做流量控制，但流量控制这种机制确实可以防止发送端向接收端过多的发送数据，但是它只关注了发送端和接收端自身的状况，而没有考虑整个网络的通信状况。于是出现了我们今天要讲的拥塞处理。



拥塞处理主要涉及到下面这几个算法

- 慢启动（Slow Start）
- 拥塞避免（Congestion Avoidance）
- 快速重传（Fast Retransmit）和快速恢复（Fast Recovery）



为了实现上面的算法，TCP 的每条连接都有两个核心状态值：

- 拥塞窗口（Congestion Window，cwnd）
- 慢启动阈值（Slow Start Threshold，ssthresh）



## 拥塞窗口

拥塞窗口指的是在收到对端 ACK 之前自己还能传输的MSS包的个数。

**它与前面介绍的接收窗口（rwnd）有什么区别呢？**

- 接收窗口（rwnd）是**接收端**的限制，是接收端还能接收的数据量大小
- 拥塞窗口（cwnd）是**发送端**的限制，是发送端在还未收到对端 ACK 之前还能发送的数据量大小



我们在 TCP 头部看到的 window 字段其实讲的是接收窗口（rwnd）大小。

拥塞窗口初始值等于操作系统的一个变量 initcwnd，最新的 linux 系统 initcwnd 默认值等于 10。



**拥塞窗口与前面介绍的发送窗口（Send Window）又有什么关系呢？**

真正的发送窗口大小 = 「接收端接收窗口大小」 与 「发送端自己拥塞窗口大小」 两者的最小值

如果接收窗口比拥塞窗口小，表示接收端处理能力不够；如果拥塞窗口小于接收窗口，表示接收端处理能力 ok，但网络拥塞。

这也很好理解，发送端能发送多少数据，取决于两个因素

- 对方能接收多少数据（接收窗口）
- 自己为了避免网络拥塞主动控制不要发送过多的数据（拥塞窗口）

发送端和接收端不会交换 cwnd 这个值，这个值是维护在发送端本地内存中的一个值，发送端和接收端最大的在途字节数（未经确认的）数据包大小只能是 rwnd 和 cwnd 的最小值。



## 拥塞控制的算法

拥塞控制的算法的本质是控制拥塞窗口（cwnd）的变化。



###慢启动

在连接建立之初，应该发多少数据给接收端才是合适的呢？

你不知道对端有多快，如果有足够的带宽，你可以选择用最快的速度传输数据，但是如果是一个缓慢的移动网络呢？如果发送的数据过多，只是造成更大的网络延迟。这是基于整个考虑，每个 TCP 连接都有一个拥塞窗口的限制，最初这个值很小，随着时间的推移，每次发送的数据量如果在不丢包的情况下，“慢慢”的递增，这种机制被称为「慢启动」

拥塞控制是从整个网络的大局观来思考的，如果没有拥塞控制，某一时刻网络的时延增加、丢包频繁，发送端疯狂重传，会造成网络更重的负担，而更重的负担会造成更多的时延和丢包，形成雪崩的网络风暴。

这个算法的过程如下：

- 第一步，三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了
- 第二步，通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小。
- 第三步，cwnd 初始值较小时，每收到一个 ACK，cwnd + 1，每经过一个 RTT，cwnd 变为之前的两倍。 过程如下图：

![image-20191003182912522](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l6v1dhzaj30ty0z0amn.jpg)

在初始拥塞窗口为 10 的情况下，拥塞窗口随时间的变化关系如下图：

![image-20191003182950017](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l6voeal3j313e0lon1g.jpg)

因此可以得到拥塞窗口达到 N 所花费的时间公式为：

![image-20191003183018225](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l6w64o6bj310i088wgj.jpg)

假设 RTT 为 50ms，客户端和服务端的接收窗口为65535字节（64KB），初始拥塞窗口为：10段，那么要达到 64KB 的吞吐量，拥塞窗口的段数 = 65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。也就是客户端和服务器之间的 64KB 的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。

早期的 Linux 的初始 cwnd 为 4，在这种情况下，需要 3.35 次 RTT，花费的实际就更长了。如果客户端和服务器之间的 RTT 很小，则这个时间基本可以忽略不计





### 慢启动阈值ssthresh

又称为**慢开始门限**。慢启动拥塞窗口（cwnd）肯定不能无止境的指数级增长下去，否则拥塞控制就变成了「拥塞失控」了，它的阈值称为「慢启动阈值」（Slow Start Threshold，ssthresh），这是文章开头介绍的拥塞控制的第二个核心状态值。ssthresh 就是一道刹车，让拥塞窗口别涨那么快。

- 当 cwnd < ssthresh 时，拥塞窗口按指数级增长（慢启动）
- 当 cwnd > ssthresh 时，拥塞窗口按线性增长（拥塞避免）（并且会把拥塞窗口设置为ssthresh）

如果发送方设置超时计时器时限已到但还没有收到确认，那么很可能是网络出现拥塞，致使报文段在网络中某处被丢弃。这时，TCP马上把拥塞窗口减小到1，同时把慢开始门限值ssthresh减半，并执行慢开始算法。





###拥塞避免

当 cwnd > ssthresh 时，拥塞窗口进入「拥塞避免」阶段，在这个阶段，每一个往返 RTT，拥塞窗口大约增加 1 个 MSS 大小。

拥塞避免把丢包当做网络拥塞的标志，如果出现了丢包的情况，必须调整窗口的大小，避免更多的包丢失。

![image-20191003184409166](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l7akwvdaj313m0fagpy.jpg)

与慢启动的区别在于

- 慢启动的做法是 RTT 时间内每收到一个 ACK，拥塞窗口 cwnd 就加 1；每经过 1 个 RTT，cwnd 翻倍
- 拥塞避免的做法保守的多，每经过一个RTT 才将拥塞窗口加 1，不管期间收到多少个 ACK

![image-20191003184503287](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l7bilh8fj311e0lutkf.jpg)

实际的算法是如下：，

- 每收到一个 ACK，将拥塞窗口增加一点点（1 / cwnd）：cwnd += 1 / cwnd

以初始 cwnd = 1 为例，cwnd 变化的过程如下图

![image-20191003184555691](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l7cfash6j30u40p0aix.jpg)

**所以是每经过 1 个 RTT，拥塞窗口「大约」增加 1**





前面介绍的慢启动和拥塞避免是 1988 年提出的拥塞控制方案，在 1990 年又出现了两种新的拥塞控制方案：「快速重传」和「快速恢复」



###快速重传

之前重传的文章中我们介绍重传的时间间隔，要等几百毫秒才会进行第一次重传。聪明的网络协议设计者们想到了一种方法：**「快速重传」**

快速重传的含义是：当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认，当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到重传定时器超时再重传。

![image-20191003184724279](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l7dystv0j30u00v9wq2.jpg)



###选择确认（SACK）

这个有一个问题，发送 3、4、5 包收到的全部是 ACK=1001，快速重传解决了一个问题: 需要重传。因为除了 2 号包，3、4、5 包也有可能丢失，那到底是只重传数据包 2 还是重传 2、3、4、5 所有包呢？

聪明的网络协议设计者，想到了一个好办法

- 收到 3 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 **1000**（ACK=1001），[1:1001]、[2001:3001] 区间的包我也收到了
- 收到 4 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 **1000**（ACK=1001），[1:1001]、[2001:4001] 区间的包我也收到了
- 收到 5 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 **1000**（ACK=1001），[1:1001]、[2001:5001] 区间的包我也收到了

这样发送端就清楚知道只用重传 2 号数据包就可以了，数据包 3、4、5已经确认无误被对端收到。这种方式被称为 SACK（Selective Acknowledgment）。

![image-20191003184833273](https://tva1.sinaimg.cn/large/006y8mN6gy1g7l7f5rq2tj30u00u24gz.jpg)





###快速恢复

当收到三次重复 ACK 时，进入快速恢复阶段。解释为网络轻度拥塞。

- 拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2
- 拥塞窗口 cwnd 设置为 ssthresh
- 拥塞窗口线性增加





**慢启动、快速恢复中的快慢是什么意思**

刚开始学习这部内容的时候，有一个疑惑，明明慢启动拥塞窗口是成指数级增长，那还叫慢？快速恢复拥塞窗口增长的这么慢，还叫快速恢复？

我的理解是慢和快不是指的拥塞窗口增长的速度，而是指它们的初始值。慢启动初始值一般都很小，快速恢复的 cwnd 设置为 ssthresh





**为什么初始化拥塞窗口 initcwnd 是 10**

根据 Google 的研究，90% 的 HTTP 请求数据都在 16KB 以内，约为 10 个 TCP 段。再大比如 16，在某些地区会出现明显的丢包，因此 10 是一个比较合理的值。