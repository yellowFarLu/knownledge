# 四次挥手

最常见的四次挥手的过程下图所示

![image-20191002182649556](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k168u2noj30ys0lkn7g.jpg)



##第一次挥手

客户端调用close方法，执行**主动关闭**，会发送一个FIN报文给服务端，这以后客户端不能再发送数据给服务端了。客户端进入**FIN-WAIT-1**状态。FIN报文其实就是把FIN字段置为1。

FIN报文段是可以携带数据的，比如客户端可以在它最后要发送的数据里面“捎带”FIN端。当然也可以不携带数据，不携带数据的话，需要消耗一个序列号。

客户端发送FIN报文之后，还可以继续接受服务端的数据，这也就是所谓的半关闭。

主动发起关闭的一方称为主动关闭方；被动发起关闭的一方称为被动关闭方。



## 第二次挥手

服务端收到FIN包以后回复确认ACK，服务端进入CLOSE-WAIT状态，客户端收到确认ACK后进入FIN-WAIT-2状态。



## 第三次挥手

服务端也没有数据发送了，发送FIN报文给客户端，然后进入LAST-ACK状态，等待客户端的ACK。同前面一样如果 FIN 段没有携带数据，也需要消耗一个序列号。



## 第四次挥手

客户端收到服务端的FIN报文后，回复ACK，进入TIME_WAIT状态，等待2个MSL以后，进入CLOSE状态。

服务端收到ACK以后，进入CLOSE状态。





**为什么 FIN 报文要消耗一个序列号**

![image-20191002190622197](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2bdxa02j30vy0o0n4r.jpg)

如上图所示，如果 FIN 包不消耗一个序列号。客户端发送了 100 字节的数据包和 FIN 包，都等待服务端确认。如果这个时候客户端收到了ACK=1000 的确认包，就无法得知到底是 100 字节的确认包还是 FIN 包的确认包。







## 同时关闭

前面介绍的都是一端收到了对端的 FIN，然后回复 ACK，随后发送自己的 FIN，等待对端的 ACK。TCP 是全双工的，当然可以两端同时发起 FIN 包。如下图所示

![image-20191002191218152](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2hkjarlj30xa0s0akt.jpg)

以客户端为例（上图貌似有问题）

- 最初客户端和服务端都处于 ESTABLISHED 状态
- 客户端发送 `FIN` 包，等待对端对这个 FIN 包的 ACK，随后进入 `FIN-WAIT-1` 状态
- 处于`FIN-WAIT-1`状态的客户端还没有等到 ACK，收到了服务端发过来的 FIN 包
- 收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 `CLOSING` 状态
- 继续等自己 FIN 包的 ACK
- 处于 `CLOSING` 状态的客户端终于等到了ACK，随后进入`TIME-WAIT`
- 在`TIME-WAIT`状态持续 2*MSL，进入`CLOSED`状态





## 问题

**为什么挥手要四次，变为三次可以吗？**

首先我们先明确一个问题，TCP 连接终止一定要四次包交互吗？三次可以吗？

当然可以，因为有**延迟确认**的存在，把第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带会对端。延迟确认后面有一节专门介绍。

![image-20191002190741603](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2crl87zj30yy0m0n3i.jpg)



如果不及时发送 ACK 包，客户端死等服务端这边发送数据，可能会造成客户端不必要的重发 FIN 包，如下图所示。

![image-20191002190930200](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2enr5syj30ha0rkn1p.jpg)

如果服务端确定没有什么数据需要发给客户端，那么当然是可以把 FIN 和 ACK 合并成一个包，四次挥手的过程就成了三次。